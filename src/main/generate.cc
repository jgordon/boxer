// C&C NLP tools
// Copyright (c) Universities of Edinburgh, Oxford and Sydney
// Copyright (c) James R. Curran
//
// This software is covered by a non-commercial use licence.
// See LICENCE.txt for the full text of the licence.
//
// If LICENCE.txt is not included in this distribution
// please email candc@it.usyd.edu.au to obtain a copy.

const char *PROGRAM_NAME = "generate";

#include "parser/_parser.h"

#include "model/model.h"

#include "io/format.h"
#include "config/format.h"

#include "io/reader.h"
#include "io/writer.h"

#include "io/reader_factory.h"

#include "io/writer_stream.h"
#include "io/writer_horiz.h"

#include "tagger/tagdict.h"
#include "tagger/tagsetdict.h"
#include "tagger/tagger.h"
#include "tagger/super.h"

#include "parser/generator.h"

#include "parser/printer.h"
#include "parser/print_stream.h"
#include "parser/print_deps.h"
#include "parser/print_grs.h"

#include "parser/decoder_derivs.h"

#include "main.h"

using namespace std;
using namespace NLP;
using namespace NLP::CCG;

const ulong MAXWORDS = 300;

int
run(int argc, char **argv){
  if(argc != 5 || (!strcmp(argv[1], "-t") && !strcmp(argv[1], "-e") && !strcmp(argv[1], "-j"))){
    cerr << "expected a flag indicating output type" << endl;
    cerr << "usage: generate -t <cats_directory> <markedup_file> <pipe_file> > <deps> 2> <feats>" << endl;
    cerr << "       generate -e <cats_directory> <markedup_file> <pipe_file> > <word_deps>" << endl;
    cerr << "       generate -j <cats_directory> <markedup_file> <pipe_file> > <word_deps>" << endl;
    cerr << "       generate -g <cats_directory> <markedup_file> <pipe_file> > <grs>" << endl;
    cerr << "       generate -T <cats_directory> <markedup_file> <pipe_file> > <raw text>" << endl;
    return 1;
  }

  bool grs = (argv[1][1] == 'g');
  bool training = (argv[1][1] == 't');
  bool julia_slots = (argv[1][1] == 'j');
  bool text = (argv[1][1] == 'T');

  const std::string CATS = argv[2];
  const std::string MARKEDUP = argv[3];
  const std::string PIPE = argv[4];

  bool ALT_MARKEDUP = grs;
  bool EXTRA_RULES = true;

  std::string command_line = argv[0];
  command_line += " ";
  command_line += argv[1];
  command_line += " ";
  command_line += argv[2];
  command_line += " ";
  command_line += argv[3];
  command_line += " ";
  command_line += argv[4];

  ulong nsentences = 0;

  std::ifstream pipe(PIPE.c_str());
  if(!pipe){
    std::cerr << "could not open pipe file '" << PIPE << "' for reading" << endl;
    exit(1);
  }

  Categories cats(CATS, MARKEDUP, ALT_MARKEDUP);
  TBSentence tb;
  Sentence sent;

  Generator gen(cats, EXTRA_RULES, MAXWORDS);

  Log log("errors.log");
  Output out(STDOUT);

  StreamPrinter::Format FMT = StreamPrinter::FMT_DEV;
  if(grs)
    FMT |= StreamPrinter::FMT_FORCE_WORDS;

  IO::HWriter writer(cout, IO::STDOUT);
  GRsPrinter printer(cats, FMT, out, log);
  DerivsDecoder decoder;

  if(!text){
    cout << "# this file was generated by the following command(s):\n";
    cout << "# " << command_line << endl; 
    cout << endl;
  }

  if(training){
    cerr << "# this file was generated by the following command(s):\n";
    cerr << "# " << command_line << endl; 
    cerr << endl;
  }

  string line;
  while(getline(pipe, line)){
    // catches the comments at the end of the CCGbank .pipe file
    if(line.compare(0,3,"###") == 0 || line.compare(0,4,"This") == 0)
      continue;
      
    if(line == ""){
      nsentences++;

      gen.convertTBsent(tb, sent);
      if(!gen.parse(tb, sent, log.stream)){
	if(text){
	  cout << "__PARSE_FAILED__\n";
	}else{
	  cout << '\n';
	  if(grs)
	    printer.failed("missing rules", sent, 0, 0);
	  if(training)
	    cerr << '\n';
	}
      }else{
	SuperCat *top = gen.chart(0,sent.words.size())[0];

	if(training){
	  gen.print_filled(cout, top);
	  cout << endl;

	  for(ulong i = 0; i < sent.words.size(); ++i)
	    cerr << "a " << sent.msuper[i][0].raw << ' ' << sent.words[i] << '\n';

	  for(ulong i = 0; i < sent.pos.size(); ++i)
	    cerr << "b " << sent.msuper[i][0].raw << ' ' << sent.pos[i] << '\n';

	  cerr << "c " << *top->cat << '\n';
	  gen.print_root(cerr, top->cat, 'd', sent.words, &top->vars[top->cat->var]);
	  gen.print_root(cerr, top->cat, 'e', sent.pos, &top->vars[top->cat->var]);

	  gen.print_deps(cerr, top, 'f', sent.words, sent.words);
	  gen.print_deps(cerr, top, 'g', sent.pos, sent.pos);
	  gen.print_deps(cerr, top, 'h', sent.words, sent.pos);
	  gen.print_deps(cerr, top, 'i', sent.pos, sent.words);
	  
	  gen.print_deps_dist(cerr, top, 'L', sent.words, sent.pos, Generator::WORDS);
	  gen.print_deps_dist(cerr, top, 'P', sent.pos, sent.pos, Generator::WORDS);

	  gen.print_deps_dist(cerr, top, 'M', sent.words, sent.pos, Generator::VERBS);
	  gen.print_deps_dist(cerr, top, 'Q', sent.pos, sent.pos, Generator::VERBS);
	    
	  gen.print_deps_dist(cerr, top, 'N', sent.words, sent.pos, Generator::PUNCT);
	  gen.print_deps_dist(cerr, top, 'R', sent.pos, sent.pos, Generator::PUNCT);
	    
	  gen.print_rules(cerr, top, 'm', 'n');
	  gen.print_rules(cerr, top, 'p', 'q', sent.words);
	  gen.print_rules(cerr, top, 'r', 's', sent.pos);
	    
	  gen.print_rules_deps(cerr, top, 't', sent.words, sent.words);
	  gen.print_rules_deps(cerr, top, 'u', sent.pos, sent.words);
	  gen.print_rules_deps(cerr, top, 'v', sent.words, sent.pos);
	  gen.print_rules_deps(cerr, top, 'w', sent.pos, sent.pos);
	    
	  gen.print_ruledeps_dist(cerr, top, 'F', sent.words, sent.pos, Generator::WORDS);
	  gen.print_ruledeps_dist(cerr, top, 'I', sent.pos, sent.pos, Generator::WORDS);

	  gen.print_ruledeps_dist(cerr, top, 'G', sent.words, sent.pos, Generator::VERBS);
	  gen.print_ruledeps_dist(cerr, top, 'J', sent.pos, sent.pos, Generator::VERBS);
	    
	  gen.print_ruledeps_dist(cerr, top, 'H', sent.words, sent.pos, Generator::PUNCT);
	  gen.print_ruledeps_dist(cerr, top, 'K', sent.pos, sent.pos, Generator::PUNCT);
	    
	  gen.print_rule_types(cerr, top, 'x');
	  cerr << endl;
	}else if(text){
	  writer.next(sent);
	}else if(grs){
	  printer.parsed(decoder.best(gen.chart), sent, 0, 0);
	}else{
	  gen.print_filled(cout, top, sent.words, julia_slots);
	  cout << endl;
	}
      }

      tb.resize(0);
      continue;
    }
    if(line == ")")
      continue;
	
    tb.push_back(TBNode(line));
  }
  
  return 0;
}
  
